#include <iostream>
#include <random>
#include <thread>
#include "TrafficLight.h"

/* Implementation of class "MessageQueue" */

 
template <typename T>
T MessageQueue<T>::receive()
{
    // FP.5a 
    std::unique_lock<std::mutex> lock(_mutex);

    // wait for and receive new messages and  
    _condition.wait(lock, [&] {
        return !_queue.empty();
    });
    // pull from the queue using move semantics
    T msg = std::move(_queue.front());
    _queue.pop_front();
    // return received object
    return msg;
}

template <typename T>
void MessageQueue<T>::send(T &&msg)
{
    // FP.4a 
    std::lock_guard<std::mutex> lock(_mutex);
    // add a new message to the queue and send a notification
    _queue.push_back(std::move(msg));
    // send
    _condition.notify_one();
}


/* Implementation of class "TrafficLight" */

 
TrafficLight::TrafficLight()
{
    _currentPhase = TrafficLightPhase::red;
}

TrafficLight::~TrafficLight() {}

void TrafficLight::waitForGreen()
{
    // FP.5b : add the implementation of the method waitForGreen, in which an infinite while-loop 
    // runs and repeatedly calls the receive function on the message queue. 
    // Once it receives TrafficLightPhase::green, the method returns.
    TrafficLightPhase receivedPhase;
    
    while (true) {
        receivedPhase = _trafficLightPhaseMQ.receive();
        std::unique_lock<std::mutex> lock(_mutex);
        std::cout << "TrafficLight #" << _id << "::waitForGreen: receivedPhase: " << receivedPhase << " thread id = " << std::this_thread::get_id() << std::endl;
        lock.unlock();
 
        if(receivedPhase == TrafficLightPhase::green) {
            break;
        }
    }
}

TrafficLightPhase TrafficLight::getCurrentPhase()
{
    std::unique_lock<std::mutex> lock(_mutex);
    return _currentPhase;
}

void TrafficLight::simulate()
{
    threads.emplace_back(std::thread(&TrafficLight::cycleThroughPhases, this)); 
}

// virtual function which is executed in a thread
void TrafficLight::cycleThroughPhases()
{
    auto randomCycleDuration = [](){
        const int minMs = 4000;
        const int maxMs = 6000-1;
        std::random_device rd;  // to obtain a seed for the random number engine
        std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
        std::uniform_int_distribution<> distrib(minMs, maxMs);
        // transform the random unsigned int generated by gen into an int 
        return distrib(gen);
    };

    auto toggleCurrentPhase = [&](){
        if(_currentPhase == TrafficLightPhase::green) {
            return TrafficLightPhase::red;
        } else { 
            // if(_currentPhase == TrafficLightPhase::red) {
            return TrafficLightPhase::green;
        }
    };

    std::unique_lock<std::mutex> lock(_mutex);
    std::cout << "TrafficLight #" << _id << "::cycleThroughPhases: thread id = " << std::this_thread::get_id() << std::endl;
    lock.unlock();

    auto start = std::chrono::system_clock::now();    
    auto now = std::chrono::system_clock::now();
    int dur = randomCycleDuration();

    // FP.2a : infinite loop that toggles the current phase of the traffic light between red and green and sends an update method 
    // to the message queue using move semantics. The cycle duration should be a random value between 4 and 6 seconds. 
    while(true) {
        // wait 1ms between two cycles
        std::this_thread::sleep_for(std::chrono::milliseconds(1));

        now = std::chrono::system_clock::now();
        std::chrono::duration<double> diff = now-start;
        if (diff.count() * 1000 > dur) {
            lock.lock();
            _currentPhase = toggleCurrentPhase();
            TrafficLightPhase toggledPhase = _currentPhase; 
            _trafficLightPhaseMQ.send(std::move(toggledPhase));
            lock.unlock();
            // reset 
            start = std::chrono::system_clock::now();
            dur = randomCycleDuration();
        }
    }

}

