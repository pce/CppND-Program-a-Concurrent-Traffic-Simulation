#include <iostream>
#include <random>
#include <thread>
#include "TrafficLight.h"

/* Implementation of class "MessageQueue" */

 
template <typename T>
T MessageQueue<T>::receive()
{
    // FP.5a : The method receive should use std::unique_lock<std::mutex> and _condition.wait() 
    // to wait for and receive new messages and pull them from the queue using move semantics. 
    // The received object should then be returned by the receive function. 
}

template <typename T>
void MessageQueue<T>::send(T &&msg)
{
    // FP.4a : The method send should use the mechanisms std::lock_guard<std::mutex> 
    // as well as _condition.notify_one() to add a new message to the queue and afterwards send a notification.
}


/* Implementation of class "TrafficLight" */

 
TrafficLight::TrafficLight()
{
    _currentPhase = TrafficLightPhase::red;
}

void TrafficLight::waitForGreen()
{
    // FP.5b : add the implementation of the method waitForGreen, in which an infinite while-loop 
    // runs and repeatedly calls the receive function on the message queue. 
    // Once it receives TrafficLightPhase::green, the method returns.
}

TrafficLightPhase TrafficLight::getCurrentPhase()
{
    return _currentPhase;
}

void TrafficLight::simulate()
{
    // FP.2b start „cycleThroughPhases“ over the thread queue in the base class
    threads.emplace_back(std::thread(&TrafficLight::cycleThroughPhases, this)); 
}

// virtual function which is executed in a thread
void TrafficLight::cycleThroughPhases()
{
    auto randomCycleDuration = [](){
        std::random_device rd;  // to obtain a seed for the random number engine
        std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
        std::uniform_int_distribution<> distrib(4000, 6000-1);
        // transform the random unsigned int generated by gen into an int 
        return distrib(gen);
    };

    auto toggleCurrentPhase = [&](){
        if(_currentPhase == TrafficLightPhase::green) {
            _currentPhase = TrafficLightPhase::red;
        } else if(_currentPhase == TrafficLightPhase::red) {
            _currentPhase = TrafficLightPhase::green;
        }
        TrafficLightPhase newPhase = _currentPhase;
        return newPhase;
    };

    std::unique_lock<std::mutex> lock(_mutex);
    // std::cout << randomCycleDuration() << std::endl; 
    std::cout << "TrafficLight #" << _id << "::cycleThroughPhases: thread id = " << std::this_thread::get_id() << std::endl;
    lock.unlock();

    auto start = std::chrono::system_clock::now();    
    auto now = std::chrono::system_clock::now();

    // FP.2a : infinite loop that toggles the current phase of the traffic light between red and green and sends an update method 
    // to the message queue using move semantics. The cycle duration should be a random value between 4 and 6 seconds. 
    while(true) {
        // wait 1ms between two cycles
        std::this_thread::sleep_for(std::chrono::milliseconds(1));

        now = std::chrono::system_clock::now();
        std::chrono::duration<double> diff = now-start;
        if (diff.count() > randomCycleDuration()) {
           TrafficLightPhase toggledPhase = toggleCurrentPhase();
            // TrafficLightPhase toggledPhase = _currentPhase; 
            _trafficLightPhaseMQ.send(std::move(toggledPhase));
            // reset 
            start = std::chrono::system_clock::now();
        }

    }

}

